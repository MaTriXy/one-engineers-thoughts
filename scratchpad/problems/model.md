
```coffee
type persona

type scenario

type stakeholder
```

> The first step towards writing the right user stories is to understand your target users and customers. After all, user stories want to tell a story about the users using the product. If you don’t know who the users are and what problem we want to solve then it’s impossible to write the right stories and you end up with a long wish list rather than a description of the relevant product functionality.

Maybe this is all considered _modeling_ or _design_.

## The First Problem

The first problem is that the current state is no different than the desired state. If that's the problem, then the problem to solve is, how to make the desired state different than the current state?

One solution is to be _creative_. This means take unobvious pieces of the current state, and mix and match. Imagine things. This is all just bringing things together that don't normally belong together, or removing things. Add/remove/change variables. This creates _novelty_.

This creates a difference from the current state.

But just because there is a current state and a _different_ state, an _alternative_ state, doesn't mean there is a problem. Instead, this is just a _possibility_.

To make it a _problem_, there has to be a desire/need to transform the current state into the alternative state. Once you want to convert the current the current state into the alternative state, you have a problem. When it's a problem, the alternative state is called the _desired_ state.

Once you have a problem, what do you do next?

Some things you do are:

- explore the problem space
- explore the solution space
- explore the hypothesis space
- thought experiments

### The Current State

The current state is the world as it is now. This includes all knowledge, all tangible and intangible things, and the history of everything that has ever happened.

### The Desired State

This is a transformation of the current state into an element of the possibility space. An element of the possibility space is a possibility, or a possible state.

The possible states can have evidence.

### Solution

A solution transforms the current state into the desired state.

A _possible solution_ is not a solution. This is sort of a _hypothesis_. Or a _proposal_. A guess or something. Maybe it's a proposition. It's not a potential. Mmm. It seems like a _conjecture_. A conjecture can be proven, but sometimes it's impossible.

### Possibility Space

- Novelty space
- Creating novelty

### Problem

### Solution

Hypothesis: the current state can transform into the desired state.

> An experiment is an orderly procedure carried out with the goal of verifying, refuting, or establishing the validity of a hypothesis.
> 
> In this sense, exploring the solution space is basically a thought experiment.
People refer to a trial solution to a problem as a hypothesis, often called an "educated guess"[7][8] because it provides a suggested solution based on the evidence. However, some scientists reject the term "educated guess" as incorrect.[9] Experimenters may test and reject several hypotheses before solving the problem.

### Problem Space

### Solution Space

Hypothetical solution will change the state of the world. So this is a hypothesis that the world will be in this state. So you have to have evidence that the world will be in this state.

As current state transforms through solutions to desired state, each point you compare your hypothesis of what the state of the world will be at each point to what it actually is.

A solution space could maybe be thought of as an _experiment_.

### Resources

- http://en.wikipedia.org/wiki/Possible_world
- http://en.wikipedia.org/wiki/Possibility_theory
- http://en.wikipedia.org/wiki/Conjecture
- http://en.wikipedia.org/wiki/Thought_experiment The common goal of a thought experiment is to explore the potential consequences of the principle in question
- the function of thought experiments is to serve as the initial step in the process of plausible argumentation as well as to test the plausibility of rival hypotheses
- http://en.wikipedia.org/wiki/Research_design
- http://en.wikipedia.org/wiki/Inference
- http://en.wikipedia.org/wiki/Observational_study
- http://en.wikipedia.org/wiki/Observation
- http://en.wikipedia.org/wiki/Project
- http://sloanreview.mit.edu/article/innovation-process-benefits-the-journey-as-reward/
- http://en.wikipedia.org/wiki/DIKW_Pyramid

### Ideas

Would be cool to include the ability to add evidence to possible solutions/hypotheses.

- How to convert solutions into tasks.

The responsibility of domain experts includes (a) breaking down the tasks into generalizable micro-tasks, so that the
tasks become relatively “de-skilled”, and therefore more amenable to crowdsourcing, (b) training and supervising
the crowd actively in performing these micro-tasks, and (c) solving a small number of micro-tasks themselves, that
the crowd finds too difficult or confusing.

## Notes

- _value network_
- Asking a question about a natural phenomenon
- Making observations of the phenomenon
- Hypothesizing an explanation for the phenomenon
- Predicting a logical consequence of the hypothesis
- Testing the hypothesis by an experiment, an observational study, or a field study
- Creating a conclusion with data gathered in the experiment, or forming a revised/new hypothesis and repeating the process

- defining the problem
- observations about the problem
- possible solutions
- predicting consequences of solutions (how one solution is input to another problem)
- implementing the solution
- revising the problem/solution spaces

Scientific method is a special case of problem solving.

open innovation, user innovation, as well as other distributed processes (cumulative innovation, communities or social production, and co-creation)

- an _explanation_ of a _phenomena_ is one form of a _solution_ to a _problem_.
  + here, the problem is we don't have an explanation
- an _answer_ to a _question_ is another form of a _solution_ to a _problem_.
  + here, the problem is we don't know the answer
- innovation is a getting to a new desired state, so innovation is a type of problem solving.
- fixing is a type of problem solving, bring current state back to older current state.
- assumption

- In the first phase, the problem is decomposed into subproblems

Problem decomposition. Hierarchy of partitionings. Decomposition proceeds until kernel (nondecomposable) subproblems are generated. The second phase involves solution of the kernel subproblems.

Problem -> leaf problems -> leaf solutions -> Solution (solution "synthesis").

Once the problem has been decomposed into kernel subproblems and they have been solved, the only answer synthesis required is recapitulation of the list of steps that have been followed to obtain the solution. For some problems
the answer synthesis phase is the dominant phase.

Answer is the "street smart" solution.

A problem may involve multiple knowledge spaces.
- variables within the problem space

how much domain knowledge does the problem solver need in order to solve the problem? This parameter determines the scale of a problem.

Precise task design is critical for data quality and meaningful evaluation metrics [23].

In the natural sciences a protocol is a predefined written procedural method in the design and implementation of experiments. Protocols are written whenever it is desirable to standardize a laboratory method to ensure successful replication of results by others in the same laboratory or by other laboratories.

Ideally, the task definition is digitized and stored in the project archive. In practice, it is documented primarily in the form of instructions to participants.

Once protocols are defined and locations assigned, it is
up to the volunteers to head out into the field to collect
data. (task completion). This step is referred to as the _event_ in our proposed
data model.

Finally, as the project evolves, the core tasks will often be refined.

Need to keep track of changes to task definitions.

### Project

A _project_ is an effort to solve a particular problem. That is, it has a _goal_, which is getting to the desired state.

A project is not something that needs to be "done", or something that "gets done". A project may not end, and it may change.

This is why projects can feel pointless: they maybe working on the wrong problem.

Potentials -> Problems -> Projects.

An ongoing project is usually called (or evolves into) a _program_.

If a program is a set of instructions, then a project is a set of instructions (tasks) maybe?

In the middle of a project, you may realize there is a better problem to solve. This is sort of "project management", which really is sort of "problem reformulation". Switching projects in this light is not a bad thing. The main goal is to get closer to the desired state, not to complete the project. And the desired state is being continuously redefined.

A team is a group of people linked by a common purpose. The purpose is to reach the desired state. If the project is defined as defining the problem, then a team can be there to clearly define the problem. While other projects could be solving the problem.

A _purpose_ is based on a problem.

### World

The context an intelligent agent exists in / is aware of. Knowledge is a set of models _in a world_ to solve problems. The world of an ant is different from a human is different from a machine.

World -> Knowledge -> Model -> Statement -> Property/Object/Relation

A mental model captures ideas in a problem domain, while a conceptual model represents 'concepts' (entities) and relationships between them. A Conceptual model in the field of computer science is also known as a domain model.

- http://en.wikipedia.org/wiki/Domain_model

The manipulation of symbols.

---

```
type problem
  property constraints
  property state(initial)
  property state(desired)
  property solutions

type world
  property models

type solution
  is model

type task

type reasoning
  is process
  is action

type model
  property statements

type knowledge
```

- A computational model of creativity

A _principle_ is a solution to a _quality_ problem. These can't be "done".

A quality problem is a problem where the desired state is not achievable, but is just better than now.

Simplicity. Beauty, clarity, purity, elegance.
Consistency. Doesn't have contradictions.
Elegant. Only includes what is _essential_. Essentials are the things that are absolutely necessary, a core part of the definition. An essense is what something fundamentally is. Our mental model.
- pure: without any extraneous and unnecessary elements, it doesn't have anything it doesn't need.

simple:
- helps you maintain clear _focus_
- _unambiguous_
- _minimalistic_
- does not have unanticipated side-effects
- not complicated: avoids unnecessary conditional logic.
- not complex or compound; single: just does one thing and does it well.
- to the point
- free of deceit or guile; sincere; unconditional: abstracts implementation from intent, but does not deceive someone by concealing or misrepresenting the actual concept.
- common or ordinary: built on standard patterns which are well understood.
- not grand or sophisticated; unpretentious: fulfills today’s needs without unnecessary bells and whistles (over-engineering).
- inconsequential or rudimentary: does not draw your attention to unnecessary details; achieves good abstractions
- http://blogs.agilefaqs.com/2009/02/02/what-is-simple-design/
- learnable
- effective
- efficient
- transparent
- simplified, reduced – the reduction aspect
- transparent, learnable – the understandability aspect
- effective, efficient – the ease of use aspect
- Simplicity is about subtracting the obvious and adding the meaningful
- for something "to be simple", it is easy to use or understand
  + use things for accomplishing a goal, solving a problem
  + simple solutions
  + simple structure
- a Simple Design is What You Need, Not What You Want
- Design lets us turn what is complex into a simpler story.

"compose simple things"

These are all things that fit our mental model of the world most robustly.

Criteria are end states, principles are the solutions. They are desired states where you can never really get there. So, principles are solutions.

Quality is a relative measurement.

Value are the desired state.

Simple vs. complicated.

---

Objects that satisfy current physiological needs will lead to positive aesthetic emotions (e.g., pleasure). Those that oppose these needs will lead to negative emotions (e.g., repulsion).

- Have a single core idea (not several ideas, or a partial idea)
  + Binary - simple enough that there are only two sides to it…allowing people to assess their agreement or not.
  + Stated in plain language - be as clear and obvious about the problem or opportunity as possible.
  + Repeated constantly - every interface should reiterate the appropriate problem or opportunity where appropriate.
  + Tied to an outcome - the end goal of each problem or opportunity should always be visible.
- Improve clarity over time (don’t overwhelm with inappropriate details)
- Use consistency (avoid using unnecessarily unique interfaces and messages)
- examples:
  + Informal and brief language. (easy to understand, minimal knowledge)
  + Intuitive, guided navigation. (easy to understand, natural model)
  + guide people one step at a time
  + less information is more helpful
- Hide the details until they're needed. That's how the same design can serve all users at once.
- easily understood or done; presenting no difficulty
- You make things simple when you bring people to understand them
  + Too much analysis is paralysis
  + Multiple ways of doing the same thing == lack of consistency
- not confusing (bewildering or perplexing)
  + doesn't drain your energy / require a lot of energy
  + Good interpretability certainly is an important aspect of the simplicity of a model
- distilling your message
- Says everything OnceAndOnlyOnce.
- code is readable
  + Good variable, method and class names
  + Variables, classes and methods that have a single purpose
  + Consistent indentation and formatting style
  + Reduction of the nesting level in code

> The reason why it depends is because if your audience isn’t used to the conditional operator, they’ll probably find code that uses it confusing.  

Simplicity depends on your existing knowledge.


not everything simple is elegant

> the ease in which somebody applies a tool to complete a task is the heart of “simplicity”. More options = more choice; which has a negative effect on the associated attribute of “ease to complete a task”

Can do a study: "What does simple look like to you?"

Syntactic simplicity, or elegance, measures the number and conciseness of the theory's basic principles.

Ontological simplicity, or parsimony, measures the number of kinds of entities postulated by the theory.

## Model

> A model is a set of equations, or functions, with one or more adjustable
parameters. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2197&rep=rep1&type=pdf

## Simplicity

- http://plato.stanford.edu/entries/simplicity/
- http://www.sveinbjorn.org/simplicity_as_theoretical_virtue
- Simplicity, Inference and Modelling: Keeping it Sophisticatedly Simple
- the cognitive system’s goal as compressing data
- coding it in such a form that it can be recovered by some computable process. the cognitive system should prefer that pattern that gives the shortest code for the data.

There are _patterns_ in raw _data_. We then transform these into _models_. We can find _features_ in data.

## intelligent machine

## Organization

- http://en.wikipedia.org/wiki/Org-mode
- http://orgmode.org/features.html

## Dynamic Programming

- dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems

http://en.wikipedia.org/wiki/Dynamic_programming

## Change Patterns

Change-Driven Model Transformations
