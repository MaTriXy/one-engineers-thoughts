
## Execution / Individual

1. model of information and reaction
  - information algebra
2. reactive system? also actions
  + soar?
  + temporal logic (metatem)
  + modern operating system implementation maybe?
  + basically just want to be storing the evolution of a graph.
  + reactive valuations! https://www.illc.uva.nl/Research/Publications/Reports/MoL-2010-17.text.pdf
  + reactive systems book
3. parsing terms into records
  - using arbology paper
  - graph pattern matching papers
4. storing/querying records boolean graph http://arxiv.org/abs/1503.02368
5. visualize problem space
  - case based reasoning

By this point, should have the basics of the model language working. With an intelligent reactive system. Then can start on the testing and verification aspects, which will make it possible to rapidly iterate on new actions, without breaking anything.

Ideally should have a model of problem solving, or product building, or innovation by this point too. So agents know know to take tasks, prioritize them, show the whole "problem space", etc.

## Testing

5. fuzzing and automated test generation
  - fuzzing book

By this point, will have a way of adding to the database, focusing on JavaScript, and know it's high quality.

---

## Publish JavaScript Actions to devhandbook

- create actions for strings
- create actions for files
- create actions for urls
- create actions for numbers
- create actions for arrays
- create actions for objects

Generate examples using basic story model from reactive system individuals with backgrounds in software development and working in silicon valley.

First draft, to see how the content can be. Will still be working, but could get to this in 6 months probably.

But don't publish to google or anything yet, still keep it private, so to avoid any mistakes.

---

## Verification

Add verification to all the actions in JavaScript, so they can be reused. And so we create a formalized model that JavaScript is using.

6. verifying records and actions
  - binary decision diagram
  - tableaux method (handbook of automated reasoning 2 volumes)
  - model checking
  - semantics with applications (operational semantics of language)

After this, can publish the JavaScript pages to search engines. And perhaps start creating content for beginners through Pinterest and Twitter, "learning to code? hard part about code is remembering everything. We got you covered." Maybe create some cool gifs showing how to do stuff, and post to Pinterest and Google+. Maybe have some articles be history oriented, to show how the style of coding evolved, or something. Then can publish these interesting history lessons to Facebook.

## Generate Code in Language

7. generate pretty code in language
  - need template strings
  - eslint
8. operational semantics to verify language
  - semantics with applications
  - wendel book?

By this point, can transform the model language code into other languages. This is where we can start creating lots of pages. By this point it is possible to use all the other languages to generate content.

This allows us to collect code from GitHub. So somehow figure out how to:

- figure out API automatically
- figure out what it does (what problems it solves, or actions it performs)
- associate these with product/action models to generate stories on how to do x with that library.

Could then possible create content for all the libraries in JavaScript.

## Add Other Languages

9. transforming grammars to automata with lr techniques
  - dragon compiler book
10. parsing model language without javascript
  - reactive system + dragon book

Now it is possible to parse the code from other languages. And it is verified. This means we could pull libraries down, and parse them into AST.

The code would be pretty and usable. This would mean lots of new content. Explosion of content in top 10 programming languages. Content about:

- language
- libraries

Then could start adding other side pieces of info like protocols and status codes and colors. And can then go into potentially automatically building small tools as a first start. Would need innovation model by then.

## Add Machine Learning

So it can keep track of problems, and do case-based reasoning. Maybe get into visual stuff?

- case based reasoning book

## Build editor

We can then build the editor. Editing text will just be another part of the reactive system. It will be able to learn how you edit code, and what you want. So it seems like adding machine learning at some point will be helpful.

## Compile to Assembly

11. compiling reactive system to target language
  - with single static assignment and compiler book
  - optimizing actions
  - engineering compiler book

This is where we can actually start using model language directly. But this isn't even necessary for a long time. From this point we can start building the editor.

agent/individual
group/collection

block
group

---

## Colors

- devhandbook
  + birch just before winter: snow and orange/red. Feeling of being by a fire in the winter all alone, to do your thing. easy to focus
- elkpress
  + color of dry grass and sandy type look, like fall with wood to make a fire and such
- factsofnature
  
